- IP 地址：指明了节点被分配到的地址，可变换，IP 地址是 32 位(ipv4)的 128s 位（ipv6）；

- MAC 地址：网卡所属的固定地址，基本不会改变，MAC 地址则是 48 位的；

  MAC 地址的长度为 48 位(6 个字节)，通常表示为 12 个 16 进制数，如：00-16-EA-AE-3C-40 就是一个 MAC 地址。形象地说，MAC 地址就如同身份证上的身份证号码，具有唯一性

- TCP 协议：提供可靠的字节流服务(将大块数据切割成报文段为单位的数据包进行管理)；

  1. 几个报文的标识的解释:

  - SYN: synchronization（同步）

  - ACK: acknowledgement（确认：告知已收到）

  - FIN: finish（结束)在 HTTP/1.1 中,keep-alive 能够复用 TCP 连接,减少 TCP 三次握手的次数,从而提升性能

  2.  三次握手：确保准确无误的将数据送达目标处，**若某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包**；

  - 发送端首先发送一个带 SYN 标志的数据包给对方；

  - 接收端收到后，回传一个带 SYN/ACK 标志的数据包标示传达确认信息；

  - 发送端再回传一个带 ACK 标志的数据包，表示握手结束；

> 三次握手而不是两次握手的原因
> 因为**网络层是不可靠的**。双方在通信的时候，就算是 TCP 连接，在网络层都有可能丢包，只不过是传输层有处理丢包的策略。若 TCP 连接是两次握手，那么突然来了一个已失效的客户端连接请求报文，服务器会把这次失效的连接当成正常的连接对待。谢希仁版计算机网络中给出的例子如下：client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了（可能是网络延迟），以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用"三次握手"，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的传输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用"三次握手"可以防止上述现象发生。
> 其实两次握手还有一个不好的地方，就是会更容易受到 SYN 攻击。原本三次握手情况下，服务器在多次等不到客户端的 ACK 报文后，就会把分配的资源释放掉。现在换成两次握手，由于没有第三次的 ACK 报文，服务器的资源就会一直被"浪费"

3.  四次挥手

    - 发送端 → 接收端 [FIN] 我要关闭连接了

    - 接收端 → 发送端 [ACK] 知道了,等我发完包先

    - 接收端 → 发送端 [FIN] 我也关闭连接了

    - 发送端 → 接收端 [ACK] 好的,知道了 TCP 协议

- DNS 协议：提供通过域名查找 IP 地址/从 IP 地址发查域名；递归查询 IP 地址（查询 www.google.com：.->.com->google.com->www.google.com）

  1. 本地域名服务器（最近一台 DNS 服务器）

  2. 根域名服务器

  3. 顶级域名服务器

  4. 全球域名服务器

- 持久连接（连接指的是 TCP 连接）

  - 实现：首部报文 Connection：Keep-alive；

    - HTTP1.1 及以上默认开启，可通过 Connection：close 关闭长连接；

    - HTTP/1.0 需要检测 Connection：keep-alive；

  - 断开

    - 首部 keep-alive 可设置超时时间，若在这段时间内没有请求发出，则断开这个长连接；

    - 一方主动断开连接；

- 提升传输效率：Accept-Encoding：gzip；

  - 内容编码：指明应用在实体内容上的编码格式(gzip、compress、deflate、identity 等)，并保持实体信息原样压缩，内容编码后的实体由客户端接收并负责解码；

    1. 浏览器发送 http request 包含 Accept-Encoding：gzip，deflate 表示浏览器支持 gzip 压缩；

    2. 服务器收到后生成原始 response，包含 content-type 和 content-length；

    3. 服务器通过 Gzip 对 response 进行编码，响应头部新增 content-encoding：gzip，然后发送给浏览器；

    4. 浏览器拿到 response 后，根据 content-encoding：gzip 对 response 进行解码，获取到原始的 response，然后显示出网页；

- 常用的网络是在 tcp / ip 协议族的基础上运作的，http 属于它内部的一个子集。

# HTTP 中的 301、302、303、307、308 响应状态码

- 301 Moved Permanently

301 状态码表明目标资源被永久的移动到了一个新的 URI，任何未来对这个资源的引用都应该使用新的 URI。

- 302 Found

由于历史原因，用户代理可能会在重定向后的请求中把 POST 方法改为 GET 方法。（但是规范是不允许的）如果不想这样，应该使用 307（Temporary Redirect） 状态码。

- 303 See Other

从语义上讲，重定向到的资源并不是你所请求的资源，而是对你所请求资源的一些描述。

303 常用于将 POST 请求重定向到 GET 请求，比如你上传了一份个人信息，服务器发回一个 303 响应，将你导向一个“上传成功”页面。

不管原请求是什么方法，重定向请求的方法都是 GET（或 HEAD，不常用）。

- 307 Temporary Redirect

307 的定义实际上和 302 是一致的，唯一的区别在于，307 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。

- 308 Permanent Redirect

308 的定义实际上和 301 是一致的，唯一的区别在于，308 状态码不允许浏览器将原本为 POST 的请求重定向到 GET 请求上。

301 & 308 都是永久重定向

302 & 303 & 307 都是临时重定向

## 302 & 303 & 307 都是临时重定向 区别：

实际效果看：302 允许各种各样的重定向，一般情况下都会实现为到 GET 的重定向，但是不能确保 POST 会重定向为 POST；而 303 只允许任意请求到 GET 的重定向；307 和 302 一样，除了不允许 POST 到 GET 的重定向。

## 简要历史原因

那为什么有了 307 和 303 还需要 302 呢？把总结放在最前面。302 在最初的定义中，内容和现在的 307 是一样的，不允许重定向方法的改写（从 POST 到 GET，由于 GET 不应该有 body，实际上 body 也被改了）。但是早期浏览器在实现的时候有的实现成 303 的效果，有的实现成 307 的效果。于是在之后的标准，302 在某些浏览器中错误的实现被写进规范，成为 303，而 302 原本的效果被复制了到了 307。在最近的一次标准修订中，302 标准被修改成不再强制需要维持原请求的方法。所以就产生了现在的 302、303 和 307
