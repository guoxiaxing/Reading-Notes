# V8 的垃圾回收机制与内存限制

## Node 与 V8

Node 的 JavaScript 引擎是 V8

## V8 的内存限制

Node 在通过 JavaScript 使用内存时会发现只能使用部分内存。会导致 Node 无法操作大内存对象。主要原因在于 Node 是基于 V8 引擎构建的，所以在 node 中使用 JavaScript 对象基本上是靠 V8 自己的方式来进行分配和管理的。

## V8 的对象分配

在 V8 中，所有的 JavaScript 对象都是通过堆来进行分配的

process.memoryUsage()

可以查看内存的使用量

heapTotal 和 heapUsed 都是 V8 内存的使用情况，前者是申请到的内存，后者是已经使用的内存

可以调整 V8 引擎内存限制，通过开启

`--max_old_space_size` 或者 `--max_new_space_size` 来调整内存限制大小

```
node --max_old_space_size=8192 ./node_modules/.bin/ng serve
```

上述参数在 V8 初始化的时候生效，一旦生效就不能再动态进行改变

## V8 的垃圾回收机制

### V8 的主要垃圾回收算法

回收策略主要基于分代式垃圾回收机制。

现代的垃圾回收机制中，根据对象的存活时间将内存的垃圾回收进行不同的分代，然后分别对不同分代的内存施以更高效的算法

1. V8 的内存分代

新生代和老生代

新生代： 驻存时间较短的对象

老生代：驻存时间较长或者常驻内存的对象

V8 堆的总体大小就是新生代和老生代所占内存的总和

`--max_old_space_size` 设置老生代内存大小

`--max_new_space_size`设置新生代内存大小

遗憾的是这两个需要在启动的时候就指定，V8 引擎无法动态的根据所用内存的大小来设置该值

64 位最大可用内存 1.4G

32 位可用最大内存 0.7G

2. 新生代的垃圾回收机制 （Scavenge 算法）

将堆内存一分为二

From To（处于闲置状态） 这两个空间

分配对象时，先在 From 空间进行分配。进行垃圾回收的时候，检查 From 空间中是否存活的对象，将他们复制到 To 空间中，然后将 From 空间释放掉，再将 To 空间中的对象对换。

当一个对象被交换过多次的时候，会被认为是老生代对象，被移到老生代当中，采用新的算法进行管理，我们称这种方式为晋升。

在 From 空间和 To 空间的对象进行交换之前回先进行判断，看是对象是否可以晋升。

晋升的条件：

1. 对象是否已经被交换过

默认情况下，对象主要存在于 From 空间中，在 From 空间向 To 空间进行交换之前，会先进行判断（判断内存地址）看是否已经经历了一次回收，如果是，就将对象从 From 空间复制到老生代空间，否则就复制到 To 空间

2. To 空间大小是否超过限制

在对象进行从 From 空间复制到 To 空间的时候判断 To 空间的大小是否超过了 25%，是则直接复制到老生代空间中。设置为 25%的原因是每次交换完成之后需要将 To 空间的对象和 From 空间进行交换，From 空间会继续用于对象的内存分分配，所以，如果占用过大，会影响后续的内存分配

3. 老生代内存回收

V8 中 标记清除和标记整理是配合使用的

Mark-Sweep（标记清除）和 Mark-Compat（标记整理）

Mark-Sweep（标记清除）：分为标记和清除两部分，不需要将内存空间划分为两半。

标记阶段： 会遍历堆中所有存活的对象，并标记。在清除阶段，清除堆中所有没有被标记的对象。

Scavenge 只复制活着的对象 （活对象在新生代中占的比较少）

Mark-Sweep 只清除没有被标记的对象（死对象在老生代中占的比较少）

所以上面这两种方式的效率比较高

标记清除法的缺点就是清除之后会导致内存不连续。所以导致后续分配一个大对象的时候，没有足够的内存空间。而当没有空间可以分配的时候又会触发一次内存分配。

Mark-Compact 的出现就是为了解决内存碎片的问题

在标记阶段，将标记为活着的对象往一端移动，移动完成之后，直接清理掉边界之外的内存

**在执行 JavaScript 代码的时候，如果正在进行垃圾回收，此时会暂停代码的执行，知道垃圾回收执行完毕**

Chrome 浏览器的每个选项卡使用一个 V8 实例

# 高效使用内存

## 作用域

解除引用

变量=null/undefined

或者使用 delete 运算符

## 闭包

在 JavaScript 中，无法进行内存回收的情况有两种：

1. 闭包

2. 全局变量

# 内存指标

## 查看内存占用的方法

1. 查看进程占用的内存 process.memoryUsage

2. 查看系统占用的内存

os 模块中的 totalmem() 和 freemem()

用于查看操作系统的内存使用情况

分别返回系统的总内存和空闲内存 单位为字节

## 堆外内存

不是有 V8 引擎分配的内存

Buffer 对象

## 总结

Node 的内存构成有 V8 分配的内存和堆外内存（node 自行分配的）而垃圾回收则约束的是 V8 内存

# 内存泄露

实质原因：

应当被回收的对象没有被回收而被存放到了老生代中

1. 缓存

2. 队列消费不及时

3. 作用域未释放

## 慎将内存当作缓存

在 Node 中一旦一个对象被作为缓存来使用，则它会长时间存在与老生代中。而且它们是没有过期时间的

## 缓存限制策略

缓存的解决方案 Redis（在进程外使用缓存）

## 关注队列状态

当生产速度大于消费速度的时候就会出现内存泄露

# 内存泄露排查

# 大内存应用

stream 处理大内存文件

由于 V8 内存的限制，我们无法使用 fs.readFile/writeFile 来操作大文件

而改用 fs.createReadStream 和 fs.createWriteStream

通过流的方式可以在进行文件操作的时候避开 V8 引擎内存大小的限制
